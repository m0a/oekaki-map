# Feature Specification: Hono RPC Migration

**Feature Branch**: `009-hono-rpc-migration`
**Created**: 2026-01-06
**Status**: Draft
**Input**: User description: "hono rpcへの移行"

## User Scenarios & Testing *(mandatory)*

### User Story 1 - Developer Experience: Type-Safe API Calls (Priority: P1)

開発者がフロントエンドからバックエンドAPIを呼び出す際、型安全性を自動的に享受できる。現在の手動fetch実装では、APIエンドポイントの変更時にフロントエンド側で型エラーが発生せず、ランタイムエラーになってしまう。Hono RPCを導入することで、バックエンドの型変更が自動的にフロントエンドに伝播し、コンパイル時にエラーを検出できる。

**Why this priority**: 最も重要な価値提供。型安全性の向上はバグの早期発見とメンテナンス性の向上に直結する。

**Independent Test**: バックエンドのAPIレスポンス型を変更した後、フロントエンドのビルドを実行し、型エラーが適切に検出されることを確認できる。

**Acceptance Scenarios**:

1. **Given** バックエンドのcanvas APIのレスポンス型を変更した場合, **When** フロントエンドのTypeScriptビルドを実行すると, **Then** 型の不一致がコンパイルエラーとして検出される
2. **Given** Hono RPCクライアントを使用してAPI呼び出しを行う場合, **When** IDEでコード補完を使用すると, **Then** バックエンドのAPI定義に基づいた正確なメソッド名とパラメータが提案される
3. **Given** 新しいAPIエンドポイントをバックエンドに追加した場合, **When** フロントエンドでクライアントを再生成すると, **Then** 新しいエンドポイントが自動的に利用可能になる

---

### User Story 2 - Code Reduction: Eliminate Boilerplate (Priority: P2)

開発者がAPI通信コードを記述する際、手動のfetch呼び出し、エラーハンドリング、型キャストなどのボイラープレートコードが不要になる。現在の`api.ts`ファイルには約200行の手動実装があるが、Hono RPCを使用することでこれらが大幅に削減される。

**Why this priority**: コード量削減は重要だが、型安全性ほど致命的ではない。既存コードが動作している限り、優先度は中程度。

**Independent Test**: 既存の`api.ts`のコード行数と、Hono RPC導入後のコード行数を比較して削減率を計測できる。

**Acceptance Scenarios**:

1. **Given** Hono RPCクライアントを導入した場合, **When** 既存のAPI呼び出しコードをRPCクライアント呼び出しに置き換えると, **Then** コード行数が少なくとも30%削減される
2. **Given** 新しいAPIエンドポイントを追加する必要がある場合, **When** バックエンドにエンドポイントを定義すると, **Then** フロントエンド側で手動でfetchコードを書く必要がない
3. **Given** API呼び出しのエラーハンドリングを実装する場合, **When** Hono RPCの統一エラーハンドリングを使用すると, **Then** 個別のtry-catchブロックが不要になる

---

### User Story 3 - Maintenance: Automatic API Contract Sync (Priority: P3)

開発者がバックエンドAPIを変更した際、フロントエンドとバックエンド間のAPI契約が自動的に同期される。現在は手動で型定義を同期する必要があり、同期漏れによるバグが発生する可能性がある。

**Why this priority**: メンテナンス性の向上は長期的には重要だが、初期導入時の優先度は低い。既存の手動プロセスでも一定の品質は保たれている。

**Independent Test**: バックエンドのAPI定義を変更し、フロントエンドのビルドプロセスで自動的に型が更新されることを確認できる。

**Acceptance Scenarios**:

1. **Given** バックエンドのCanvas型定義にフィールドを追加した場合, **When** フロントエンドでRPCクライアントを使用すると, **Then** 新しいフィールドが自動的にアクセス可能になる
2. **Given** 複数の開発者が並行してAPIを変更する場合, **When** 各開発者がローカルでビルドすると, **Then** 最新のAPI定義が常に反映される
3. **Given** CI/CDパイプラインでビルドを実行する場合, **When** API定義の不整合がある場合, **Then** ビルドが失敗してデプロイ前に問題を検出できる

---

### Edge Cases

- すべてのJSON APIエンドポイントを一括でRPCに切り替える（ビッグバン移行）。移行中の新旧実装混在は発生しない。FormDataエンドポイントのみ手動fetch実装を継続する
- デプロイタイミングのずれによるAPI不一致は発生しない。Cloudflare Workersの単一デプロイメントにより、フロントエンド（SPA）とバックエンド（API）は常に同時にデプロイされる
- FormData（画像アップロードなど）を使用するエンドポイントは現状の手動fetch実装を維持する。Hono RPC 4.6.0はFormDataを直接サポートしていないため、実績のある既存実装（タイル保存、OGP画像アップロード）を変更しない
- CORS対応は不要。開発環境（Viteプロキシ）と本番環境（Cloudflare Workers）の両方で同一オリジンからAPI提供されるため、追加のCORS設定やカスタムヘッダーは必要ない
- タイル画像（`/api/tiles/:canvasId/:z/:x/:y.webp`）は`<img>`タグで直接URL参照を継続。ブラウザの標準キャッシュ機構を活用し、RPC経由のBlob取得は行わない。バイナリレスポンスでは型安全性のメリットが限定的なため

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: システムはHono RPCを使用してフロントエンドとバックエンド間のAPI通信を実現しなければならない
- **FR-002**: システムはバックエンドのAPI型定義からフロントエンド用の型安全なクライアントを自動生成しなければならない
- **FR-003**: JSON API呼び出し（Canvas CRUD、Layers CRUD、OGP取得）がHono RPCクライアント経由で動作しなければならない
- **FR-004**: FormDataを使用する画像アップロードエンドポイント（タイル保存、OGP画像）は現状の手動fetch実装を維持し、正しく動作しなければならない
- **FR-005**: 既存のエラーハンドリングロジックが維持または改善されなければならない
- **FR-006**: 既存のAPI URL構造（`/api/canvas`、`/api/tiles`など）との互換性を維持しなければならない
- **FR-007**: 開発環境でのホットリロード時にRPCクライアントの型情報が自動的に更新されなければならない
- **FR-008**: 既存のHTTP動作（同一オリジン通信）が引き続き機能しなければならない。CORS対応は同一オリジン前提のため不要

### Key Entities

- **RPC Client**: バックエンドの`AppType`から生成される型安全なAPIクライアント。すべてのエンドポイントに対するメソッドを提供する
- **API Routes**: バックエンドのHonoルート定義。Canvas、Tiles、Layers、OGPの各ドメインごとに組織化されている
- **Type Definitions**: バックエンドとフロントエンド間で共有される型定義。現在は手動で同期されているが、RPCで自動化される

## Clarifications

### Session 2026-01-06

- Q: FormData（画像アップロードなど）を使用するエンドポイントはHono RPCでどう扱うか？ → A: FormDataエンドポイントは現状のfetchのまま維持
- Q: 既存の手動fetch実装とHono RPCクライアントが混在する移行期間中の動作はどうなるか？ → A: すべてのエンドポイントを一括でRPCに切り替え（ビッグバン移行）
- Q: バックエンドとフロントエンドのデプロイタイミングがずれた場合、APIバージョンの不一致はどう扱うか？ → A: 単一デプロイ（フロントエンドとバックエンドを同時にデプロイ）
- Q: CORS設定やカスタムヘッダーが必要なエンドポイントの対応はどうするか？ → A: 現状維持（CORS対応不要、同一オリジン前提）
- Q: 大きなレスポンス（タイル画像など）のストリーミングやキャッシュ制御はどう扱うか？ → A: 現状維持（imgタグで直接URL参照、RPC不使用）

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: API呼び出しのコード行数が既存実装と比較して30%以上削減される
- **SC-002**: バックエンドのAPI型変更時、フロントエンドのビルドで100%の型エラー検出率を達成する
- **SC-003**: すべての既存機能（描画、保存、共有、レイヤー管理）がHono RPC導入後も同じ動作を維持する
- **SC-004**: 開発者がバックエンドAPI定義を変更してから、フロントエンドで新しい型が利用可能になるまでの時間が1分以内になる
- **SC-005**: API呼び出しの平均レスポンス時間が既存実装と比較して同等または改善される（パフォーマンス劣化なし）

## Assumptions

- Hono RPCは`hono/client`パッケージの標準機能を使用する
- 既存のバックエンドAPI構造（Honoルーター、エンドポイント）は大きく変更せず、型エクスポートの追加程度で対応可能
- フロントエンドのビルドプロセス（Vite）はHono RPCクライアントの生成を統合できる
- 開発環境でバックエンドとフロントエンドは同一オリジンで動作する（プロキシ設定済み）
- 本番環境では静的ファイルとAPIが同じドメインから提供される（Cloudflare Workers）

## Out of Scope

以下は今回の移行では対象外とする：

- GraphQLやtRPCなど、Hono RPC以外のRPCフレームワークの検討
- バックエンドAPIの構造変更やリファクタリング
- WebSocketやServer-Sent Eventsなどのリアルタイム通信機能の追加
- API バージョニング戦略の導入
- モックサーバーやスタブの自動生成
